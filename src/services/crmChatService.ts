import { supabase } from '../lib/supabase'

export interface ChatConversation {
    id: string
    empresa_id: string
    cliente_id?: string
    lead_id?: string
    status: 'aberto' | 'resolvido' | 'arquivado'
    modo: 'bot' | 'humano'
    titulo?: string
    foto_contato?: string
    canal?: string
    nome?: string
    criado_em: string
    updated_at: string
    cliente?: { id: string, nome_cliente: string, email: string, telefone: string }
    lead?: { id: string, nome: string, email: string, telefone: string }
    lastMessage?: ChatMessage
    unreadCount?: number
}

export interface ChatMessage {
    id: string
    conversa_id: string
    remetente_tipo: 'usuario' | 'sistema' | 'cliente'
    remetente_id?: string
    conteudo: string
    tipo_conteudo: 'texto' | 'imagem' | 'arquivo' | 'agendamento'
    lido: boolean
    criado_em: string
    metadados?: any // JSONB for flexible data (e.g. appointment details)
}

export const crmChatService = {
    async getConversations(empresaId: string): Promise<ChatConversation[]> {
        const { data, error } = await supabase
            .from('crm_chat_conversas')
            .select(`
                *,
                cliente:cliente_id ( id, nome_cliente, email, telefone ),
                lead:lead_id ( id, nome, email, telefone )
            `)
            .eq('empresa_id', empresaId)
            .order('updated_at', { ascending: false })

        if (error) throw error

        const conversations = await Promise.all(data.map(async (conv) => {
            const { data: lastMsg } = await supabase
                .from('crm_chat_mensagens')
                .select('*')
                .eq('conversa_id', conv.id)
                .order('criado_em', { ascending: false })
                .limit(1)
                .single()

            const { count: unread } = await supabase
                .from('crm_chat_mensagens')
                .select('*', { count: 'exact', head: true })
                .eq('conversa_id', conv.id)
                .eq('lido', false)
                .eq('remetente_tipo', 'cliente') // Count only client messages

            return {
                ...conv,
                lastMessage: lastMsg || null,
                unreadCount: unread || 0
            }
        }))

        return conversations as ChatConversation[]
    },

    async getMessages(conversaId: string): Promise<ChatMessage[]> {
        const { data, error } = await supabase
            .from('crm_chat_mensagens')
            .select('*')
            .eq('conversa_id', conversaId)
            .order('criado_em', { ascending: true })

        if (error) throw error
        return data as ChatMessage[]
    },

    async sendMessage(
        conversaId: string,
        conteudo: string,
        remetenteTipo: 'usuario' | 'sistema' | 'cliente',
        remetenteId?: string,
        tipoConteudo: 'texto' | 'imagem' | 'arquivo' | 'agendamento' = 'texto',
        metadados?: any
    ): Promise<ChatMessage> {
        const { data, error } = await supabase
            .from('crm_chat_mensagens')
            .insert({
                conversa_id: conversaId,
                conteudo,
                remetente_tipo: remetenteTipo,
                remetente_id: remetenteId,
                tipo_conteudo: tipoConteudo,
                metadados: metadados, // Ensure DB column 'metadados' exists (JSONB)
                lido: remetenteTipo === 'usuario' // If sent by user, it's read
            })
            .select()
            .single()

        if (error) throw error

        // Update conversation updated_at
        await supabase
            .from('crm_chat_conversas')
            .update({ updated_at: new Date().toISOString() })
            .eq('id', conversaId)

        return data as ChatMessage
    },

    async createConversation(
        empresaId: string,
        title: string,
        data: {
            id?: string, // Manual ID (e.g. phone number)
            clienteId?: string,
            leadId?: string,
            canal?: string,
            foto_contato?: string,
            nome?: string
        }
    ): Promise<ChatConversation> {
        const { data: conv, error } = await supabase
            .from('crm_chat_conversas')
            .insert({
                id: data.id, // Optional, can be auto-generated by DB if uuid, but we want text/phone
                empresa_id: empresaId,
                titulo: title,
                cliente_id: data.clienteId,
                lead_id: data.leadId,
                canal: data.canal,
                foto_contato: data.foto_contato,
                nome: data.nome,
                modo: 'bot',
                status: 'aberto'
            })
            .select()
            .single()

        if (error) throw error
        return conv as ChatConversation
    },

    async updateStatus(conversaId: string, status: 'aberto' | 'resolvido' | 'arquivado'): Promise<void> {
        const { error } = await supabase
            .from('crm_chat_conversas')
            .update({ status })
            .eq('id', conversaId)

        if (error) throw error
    },

    async toggleMode(conversaId: string, modo: 'bot' | 'humano'): Promise<void> {
        const { error } = await supabase
            .from('crm_chat_conversas')
            .update({ modo })
            .eq('id', conversaId)

        if (error) throw error
    },

    async updateConversation(conversaId: string, updates: Partial<ChatConversation>): Promise<void> {
        const { error } = await supabase
            .from('crm_chat_conversas')
            .update(updates)
            .eq('id', conversaId)

        if (error) throw error
    },

    async markAsRead(conversaId: string): Promise<void> {
        await supabase
            .from('crm_chat_mensagens')
            .update({ lido: true })
            .eq('conversa_id', conversaId)
            .eq('remetente_tipo', 'cliente')
            .eq('lido', false)
    },

    async sendToWebhook(payload: {
        conversaId: string
        conteudo: string
        remetenteId?: string
        remetenteTipo: string
        timestamp: string
    }): Promise<void> {
        try {
            const { error } = await supabase.functions.invoke('crm-webhook-proxy', {
                body: payload
            })

            if (error) throw error
        } catch (error) {
            console.error('Error sending to webhook:', error)
        }
    },

    async deleteConversation(conversaId: string): Promise<void> {
        // 1. Delete messages
        const { error: errorMessages } = await supabase
            .from('crm_chat_mensagens')
            .delete()
            .eq('conversa_id', conversaId)

        if (errorMessages) throw errorMessages

        // 2. Delete from mel_chat (session_id = phone/id)
        const { error: errorMel } = await supabase
            .from('mel_chat')
            .delete()
            .eq('session_id', conversaId)

        if (errorMel) {
            console.error('Error deleting from mel_chat:', errorMel)
            // Continue to delete conversation even if mel_chat fail (might not exist)
        }

        // 3. Delete conversation
        const { error } = await supabase
            .from('crm_chat_conversas')
            .delete()
            .eq('id', conversaId)

        if (error) throw error
    }
}
